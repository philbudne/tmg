"""
Ptthon script to postprocess tmgl7a output
to make code acceptabe to as7 and PDP-7 tmgl builtins
only handles cases generated by tmgl7a running over itself!
"""

import sys
import re

STR_RE = re.compile("<[^>]*>")

UNPRINT = [ord(x) for x in '\t <\\']
def pr(x):
    if x in UNPRINT:
        return False
    if x <= 0o40 or x > 0o176:
        return False
    return True

BUILTINS = {
    "octal": "octal",
    "char": "char",
    "table": "table",
    "getname": "getname",
    "mark": "mark",
    "string": "string",

    # PDP-11 ops (porting aid, until tmgl7a is static)
    ".pop": ".pop",
    "_p": ".pop",
    "smark": "mark",
    "ignore": "ign11",
#   "table": "tab11",
    "any": "char",
}

end_next = ''
prev = ''
for line in sys.stdin.readlines():
    if end_next:
        if not line.startswith('x '):
            line = end_next + line
        end_next = ''

    # PDP-11 uses bare address for both builtins and TMG code
    # (determines which by address range)
    # need to have a TMG rule that recognizes all builtins???

    ls = line.strip()
    if ls == 'parse':
        line = 'rf parsedo\n'
    elif ls == 'x parse':
        line = 'rf parsedo\n'
        end_next = 'x '
    elif ls in BUILTINS:
        line = 'rf %s\n' % BUILTINS[ls]
    elif ls.startswith('x '):
        x, op = ls.split(' ', 1)
        if op in BUILTINS:
            line = 'x rf %s\n' % BUILTINS[op]
    elif line.startswith('<') and line.endswith('>\n'):
        # split up string lits
        # wondering if lit strings were dumped out by symoct (in octal)?!
        # OR if PDP-7 TMGL only had two-char lits?
        # OR whether a looping rule with char(nogt) char(nogt) would work
        #   to peel of character pairs? lots of pain/exceptions to handle!
        s = line[1:-2]
        out = []
        while len(s) > 1:
            s0 = s[0]
            s1 = s[1]
            o0 = ord(s0)
            o1 = ord(s1)
            if pr(o0):
                if pr(o1):
                    out.append("<%s%s>" % (s0, s1))
                else:
                    out.append("<%s %03o" % (s0, o1))
            elif pr(o1):
                out.append("%03o000 %s>" % (o0, s1))
            else:
                out.append("%03o%03o" % (o0, o1))
            s = s[2:]
        if len(s) == 1:
            s0 = s[0]
            o0 = ord(s0)
            if pr(o0):
                out.append("<%s 0777" % s0)
            else:
                out.append("%03o777" % o0)
        else:
            out.append('end')
        line = '; '.join(out) + '\n'
    elif ls and ':' not in line and '=' not in line and ' ' not in line:
        if not line[0].isdigit():
            pass
# XXX must exclude opcodes!!!
#            if 'rf char' not in prev and 'rf string' not in prev:
#                line = 'rc ' + line
    prev = line
    sys.stdout.write(line)
